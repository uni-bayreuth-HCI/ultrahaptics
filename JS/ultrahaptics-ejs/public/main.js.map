{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///../node_modules/d3-array/src/range.js","webpack:///../node_modules/axios/index.js","webpack:///../node_modules/axios/lib/adapters/xhr.js","webpack:///../node_modules/axios/lib/axios.js","webpack:///../node_modules/axios/lib/cancel/Cancel.js","webpack:///../node_modules/axios/lib/cancel/CancelToken.js","webpack:///../node_modules/axios/lib/cancel/isCancel.js","webpack:///../node_modules/axios/lib/core/Axios.js","webpack:///../node_modules/axios/lib/core/InterceptorManager.js","webpack:///../node_modules/axios/lib/core/buildFullPath.js","webpack:///../node_modules/axios/lib/core/createError.js","webpack:///../node_modules/axios/lib/core/dispatchRequest.js","webpack:///../node_modules/axios/lib/core/enhanceError.js","webpack:///../node_modules/axios/lib/core/mergeConfig.js","webpack:///../node_modules/axios/lib/core/settle.js","webpack:///../node_modules/axios/lib/core/transformData.js","webpack:///../node_modules/axios/lib/defaults.js","webpack:///../node_modules/axios/lib/helpers/bind.js","webpack:///../node_modules/axios/lib/helpers/buildURL.js","webpack:///../node_modules/axios/lib/helpers/combineURLs.js","webpack:///../node_modules/axios/lib/helpers/cookies.js","webpack:///../node_modules/axios/lib/helpers/isAbsoluteURL.js","webpack:///../node_modules/axios/lib/helpers/isAxiosError.js","webpack:///../node_modules/axios/lib/helpers/isURLSameOrigin.js","webpack:///../node_modules/axios/lib/helpers/normalizeHeaderName.js","webpack:///../node_modules/axios/lib/helpers/parseHeaders.js","webpack:///../node_modules/axios/lib/helpers/spread.js","webpack:///../node_modules/axios/lib/utils.js","webpack:///./js/getTotalLengthAllPaths.js","webpack:///./js/pathologize.js","webpack:///./js/pathsToCoords.js","webpack:///./js/polygonize.js","webpack:///./js/startApp.js","webpack:///../node_modules/pathologist/dist/pathologist.es.js","webpack:///webpack/runtime/compat get default export","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./main.js"],"names":["prev","curr","reText","reStyle","removedText","original","removedStyle","pathologized","pathologist","totalLengthAllPaths","getTotalLengthAllPaths","runningPointsTotal","separatePathsCoordsCollection","index","paths","pointsForPath","Math","numPoints","item","polygonize","length","path","point","window","renderSVGInHTML","document","pathsToCoords","data","handleFileUpload","file","reader","pathologize","handleRenderButtonCLicked","console","axios","method","url","coordinates","scale","translateX","translateY","main","startApp"],"mappings":"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","file":"main.js","sourcesContent":["// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","export default function(start, stop, step) {\n  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;\n\n  var i = -1,\n      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,\n      range = new Array(n);\n\n  while (++i < n) {\n    range[i] = start + i * step;\n  }\n\n  return range;\n}\n","module.exports = require('./lib/axios');","'use strict';\n\nvar utils = require('./../utils');\nvar settle = require('./../core/settle');\nvar cookies = require('./../helpers/cookies');\nvar buildURL = require('./../helpers/buildURL');\nvar buildFullPath = require('../core/buildFullPath');\nvar parseHeaders = require('./../helpers/parseHeaders');\nvar isURLSameOrigin = require('./../helpers/isURLSameOrigin');\nvar createError = require('../core/createError');\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    // Listen for ready state\n    request.onreadystatechange = function handleLoad() {\n      if (!request || request.readyState !== 4) {\n        return;\n      }\n\n      // The request errored out and we didn't get a response, this will be\n      // handled by onerror instead\n      // With one exception: request that using file: protocol, most browsers\n      // will return status as 0 even though it's a successful request\n      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n        return;\n      }\n\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;\n      var response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(resolve, reject, response);\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(createError('Request aborted', config, 'ECONNABORTED', request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?\n        cookies.read(config.xsrfCookieName) :\n        undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (config.responseType) {\n      try {\n        request.responseType = config.responseType;\n      } catch (e) {\n        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.\n        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.\n        if (config.responseType !== 'json') {\n          throw e;\n        }\n      }\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n\n        request.abort();\n        reject(cancel);\n        // Clean up request\n        request = null;\n      });\n    }\n\n    if (!requestData) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n","'use strict';\n\nvar utils = require('./utils');\nvar bind = require('./helpers/bind');\nvar Axios = require('./core/Axios');\nvar mergeConfig = require('./core/mergeConfig');\nvar defaults = require('./defaults');\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Factory for creating new instances\naxios.create = function create(instanceConfig) {\n  return createInstance(mergeConfig(axios.defaults, instanceConfig));\n};\n\n// Expose Cancel & CancelToken\naxios.Cancel = require('./cancel/Cancel');\naxios.CancelToken = require('./cancel/CancelToken');\naxios.isCancel = require('./cancel/isCancel');\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = require('./helpers/spread');\n\n// Expose isAxiosError\naxios.isAxiosError = require('./helpers/isAxiosError');\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = axios;\n","'use strict';\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n","'use strict';\n\nvar Cancel = require('./Cancel');\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n","'use strict';\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n","'use strict';\n\nvar utils = require('./../utils');\nvar buildURL = require('../helpers/buildURL');\nvar InterceptorManager = require('./InterceptorManager');\nvar dispatchRequest = require('./dispatchRequest');\nvar mergeConfig = require('./mergeConfig');\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = arguments[1] || {};\n    config.url = arguments[0];\n  } else {\n    config = config || {};\n  }\n\n  config = mergeConfig(this.defaults, config);\n\n  // Set config.method\n  if (config.method) {\n    config.method = config.method.toLowerCase();\n  } else if (this.defaults.method) {\n    config.method = this.defaults.method.toLowerCase();\n  } else {\n    config.method = 'get';\n  }\n\n  // Hook up interceptors middleware\n  var chain = [dispatchRequest, undefined];\n  var promise = Promise.resolve(config);\n\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  while (chain.length) {\n    promise = promise.then(chain.shift(), chain.shift());\n  }\n\n  return promise;\n};\n\nAxios.prototype.getUri = function getUri(config) {\n  config = mergeConfig(this.defaults, config);\n  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\\?/, '');\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: (config || {}).data\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n","'use strict';\n\nvar utils = require('./../utils');\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n","'use strict';\n\nvar isAbsoluteURL = require('../helpers/isAbsoluteURL');\nvar combineURLs = require('../helpers/combineURLs');\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n * @returns {string} The combined full path\n */\nmodule.exports = function buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n};\n","'use strict';\n\nvar enhanceError = require('./enhanceError');\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n","'use strict';\n\nvar utils = require('./../utils');\nvar transformData = require('./transformData');\nvar isCancel = require('../cancel/isCancel');\nvar defaults = require('../defaults');\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData(\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData(\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData(\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n","'use strict';\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n\n  error.request = request;\n  error.response = response;\n  error.isAxiosError = true;\n\n  error.toJSON = function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code\n    };\n  };\n  return error;\n};\n","'use strict';\n\nvar utils = require('../utils');\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n * @returns {Object} New object resulting from merging config2 to config1\n */\nmodule.exports = function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  var config = {};\n\n  var valueFromConfig2Keys = ['url', 'method', 'data'];\n  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];\n  var defaultToConfig2Keys = [\n    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',\n    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',\n    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',\n    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',\n    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'\n  ];\n  var directMergeKeys = ['validateStatus'];\n\n  function getMergedValue(target, source) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge(target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  function mergeDeepProperties(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(config1[prop], config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(undefined, config2[prop]);\n    }\n  });\n\n  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);\n\n  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(undefined, config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  });\n\n  utils.forEach(directMergeKeys, function merge(prop) {\n    if (prop in config2) {\n      config[prop] = getMergedValue(config1[prop], config2[prop]);\n    } else if (prop in config1) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  });\n\n  var axiosKeys = valueFromConfig2Keys\n    .concat(mergeDeepPropertiesKeys)\n    .concat(defaultToConfig2Keys)\n    .concat(directMergeKeys);\n\n  var otherKeys = Object\n    .keys(config1)\n    .concat(Object.keys(config2))\n    .filter(function filterAxiosKeys(key) {\n      return axiosKeys.indexOf(key) === -1;\n    });\n\n  utils.forEach(otherKeys, mergeDeepProperties);\n\n  return config;\n};\n","'use strict';\n\nvar createError = require('./createError');\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn(data, headers);\n  });\n\n  return data;\n};\n","'use strict';\n\nvar utils = require('./utils');\nvar normalizeHeaderName = require('./helpers/normalizeHeaderName');\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = require('./adapters/xhr');\n  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    // For node use HTTP adapter\n    adapter = require('./adapters/http');\n  }\n  return adapter;\n}\n\nvar defaults = {\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Accept');\n    normalizeHeaderName(headers, 'Content-Type');\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data)) {\n      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');\n      return JSON.stringify(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    /*eslint no-param-reassign:0*/\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data);\n      } catch (e) { /* Ignore */ }\n    }\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\n\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n","'use strict';\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    var hashmarkIndex = url.indexOf('#');\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n","'use strict';\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n    (function standardBrowserEnv() {\n      return {\n        write: function write(name, value, expires, path, domain, secure) {\n          var cookie = [];\n          cookie.push(name + '=' + encodeURIComponent(value));\n\n          if (utils.isNumber(expires)) {\n            cookie.push('expires=' + new Date(expires).toGMTString());\n          }\n\n          if (utils.isString(path)) {\n            cookie.push('path=' + path);\n          }\n\n          if (utils.isString(domain)) {\n            cookie.push('domain=' + domain);\n          }\n\n          if (secure === true) {\n            cookie.push('secure');\n          }\n\n          document.cookie = cookie.join('; ');\n        },\n\n        read: function read(name) {\n          var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n          return (match ? decodeURIComponent(match[3]) : null);\n        },\n\n        remove: function remove(name) {\n          this.write(name, '', Date.now() - 86400000);\n        }\n      };\n    })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return {\n        write: function write() {},\n        read: function read() { return null; },\n        remove: function remove() {}\n      };\n    })()\n);\n","'use strict';\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n","'use strict';\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nmodule.exports = function isAxiosError(payload) {\n  return (typeof payload === 'object') && (payload.isAxiosError === true);\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n    (function standardBrowserEnv() {\n      var msie = /(msie|trident)/i.test(navigator.userAgent);\n      var urlParsingNode = document.createElement('a');\n      var originURL;\n\n      /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n      function resolveURL(url) {\n        var href = url;\n\n        if (msie) {\n        // IE needs attribute set twice to normalize properties\n          urlParsingNode.setAttribute('href', href);\n          href = urlParsingNode.href;\n        }\n\n        urlParsingNode.setAttribute('href', href);\n\n        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n        return {\n          href: urlParsingNode.href,\n          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n          host: urlParsingNode.host,\n          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n          hostname: urlParsingNode.hostname,\n          port: urlParsingNode.port,\n          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n            urlParsingNode.pathname :\n            '/' + urlParsingNode.pathname\n        };\n      }\n\n      originURL = resolveURL(window.location.href);\n\n      /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n      return function isURLSameOrigin(requestURL) {\n        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n        return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n      };\n    })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return function isURLSameOrigin() {\n        return true;\n      };\n    })()\n);\n","'use strict';\n\nvar utils = require('../utils');\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = [\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n];\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n\n  return parsed;\n};\n","'use strict';\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n","'use strict';\n\nvar bind = require('./helpers/bind');\n\n/*global toString:true*/\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return (typeof FormData !== 'undefined') && (val instanceof FormData);\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {Object} val The value to test\n * @return {boolean} True if value is a plain Object, otherwise false\n */\nfunction isPlainObject(val) {\n  if (toString.call(val) !== '[object Object]') {\n    return false;\n  }\n\n  var prototype = Object.getPrototypeOf(val);\n  return prototype === null || prototype === Object.prototype;\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\n                                           navigator.product === 'NativeScript' ||\n                                           navigator.product === 'NS')) {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (isPlainObject(result[key]) && isPlainObject(val)) {\n      result[key] = merge(result[key], val);\n    } else if (isPlainObject(val)) {\n      result[key] = merge({}, val);\n    } else if (isArray(val)) {\n      result[key] = val.slice();\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n * @return {string} content value without BOM\n */\nfunction stripBOM(content) {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isPlainObject: isPlainObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim,\n  stripBOM: stripBOM\n};\n","export default function getTotalLengthAllPaths (paths) {\r\n  return Array.from(paths).reduce((prev, curr) => {\r\n    return prev + curr.getTotalLength();\r\n  }, 0);\r\n}\r\n","//Thank you Rich!! https://pathologist.surge.sh/\r\nimport * as pathologist  from 'pathologist';\r\n\r\nexport default function pathologize (original) {\r\n\r\n  //handles issues with pathologist not parsing text and style elements\r\n  const reText = /<text[\\s\\S]*?<\\/text>/g;\r\n  const reStyle = /<style[\\s\\S]*?<\\/style>/g;\r\n  const removedText = original.replace(reText, '');\r\n  const removedStyle = removedText.replace(reStyle, '');\r\n\r\n  try {\r\n    const pathologized = pathologist.transform(removedStyle);\r\n    return pathologized;\r\n  } catch (e)  {\r\n    return original;\r\n  }\r\n}","import polygonize from './polygonize';\r\nimport getTotalLengthAllPaths from './getTotalLengthAllPaths';\r\n\r\n\r\nexport default function pathsToCoords ( paths, scale, numPoints, translateX, translateY ) {\r\n  const totalLengthAllPaths = getTotalLengthAllPaths( paths );\r\n\r\n  let runningPointsTotal = 0;\r\n  const separatePathsCoordsCollection = Array.from(paths).reduce((prev, item, index) => {\r\n    let pointsForPath;\r\n    if (index + 1 === paths.length) {\r\n      //ensures that the total number of points = the actual requested number (because using rounding)\r\n      pointsForPath = numPoints - runningPointsTotal;\r\n    } else {\r\n      pointsForPath = Math.round(numPoints * item.getTotalLength() / totalLengthAllPaths);\r\n      runningPointsTotal += pointsForPath;\r\n    }\r\n    return [...prev, ...polygonize(item, pointsForPath, scale, translateX, translateY)];\r\n  }, []);\r\n  return separatePathsCoordsCollection;\r\n}\r\n","import { range } from 'd3-array';\r\n\r\nexport default function polygonize (path, numPoints, scale, translateX, translateY) {\r\n  //Thank you Noah!! http://bl.ocks.org/veltman/fc96dddae1711b3d756e0a13e7f09f24\r\n\r\n  const length = path.getTotalLength();\r\n\r\n  return range(numPoints).map(function(i) {\r\n    const point = path.getPointAtLength(length * i / numPoints);\r\n    return [point.x * scale + translateX, point.y * scale + translateY];\r\n  });\r\n}\r\n","import pathologize from './pathologize';\r\nimport pathsToCoords from './pathsToCoords';\r\nimport axios from 'axios';\r\nvar data= {\r\n    scale:1,\r\n    numPoints:1000,\r\n    translateX:1,\r\n    translateY:1\r\n}\r\n\r\nexport default function startApp () {\r\n    window.coordinates;\r\n    var handleFileUpload = function (e) {\r\n        let file = this.files[0];\r\n        if (file.type === 'image/svg+xml') {\r\n            const reader = new FileReader();\r\n            reader.onload = function() {\r\n                renderSVGInHTML(pathologize(reader.result));\r\n            };\r\n            reader.readAsText(file);\r\n          }\r\n    }\r\n\r\n    var renderSVGInHTML = function (pathsOnly) {\r\n        // document.body.appendChild(pathsOnly)\r\n        document.getElementById('svg-holder').innerHTML = pathsOnly\r\n        var paths = document.getElementById('svg-holder').getElementsByTagName('path');\r\n        window.coordinates=pathsToCoords(paths, data.scale, data.numPoints, data.translateX, data.translateY)\r\n\r\n    }\r\n\r\n    var handleRenderButtonCLicked = function() {\r\n        console.log(window.coordinates)\r\n        axios({\r\n            method: 'post',\r\n            url: '/render',\r\n            data: {\r\n              coordinates: window.coordinates,\r\n            }\r\n          }).then(function (response) {\r\n            \r\n          });\r\n          \r\n    }\r\n\r\n    document.querySelector('#file_upload').addEventListener(\"change\", handleFileUpload)\r\n    document.getElementById('render-button').addEventListener('click', handleRenderButtonCLicked)\r\n}","function getLocator ( source ) {\n\tvar originalLines = source.split( '\\n' );\n\n\tvar start = 0;\n\tvar lineRanges = originalLines.map( function ( line, i ) {\n\t\tvar end = start + line.length + 1;\n\t\tvar range = { start: start, end: end, line: i };\n\n\t\tstart = end;\n\t\treturn range;\n\t});\n\n\tvar i = 0;\n\n\tfunction rangeContains ( range, index ) {\n\t\treturn range.start <= index && index < range.end;\n\t}\n\n\tfunction getLocation ( range, index ) {\n\t\treturn { line: range.line, column: index - range.start, character: index };\n\t}\n\n\treturn function locate ( search, startIndex ) {\n\t\tif ( typeof search === 'string' ) {\n\t\t\tsearch = source.indexOf( search, startIndex || 0 );\n\t\t}\n\n\t\tvar range = lineRanges[i];\n\n\t\tvar d = search >= range.end ? 1 : -1;\n\n\t\twhile ( range ) {\n\t\t\tif ( rangeContains( range, search ) ) return getLocation( range, search );\n\n\t\t\ti += d;\n\t\t\trange = lineRanges[i];\n\t\t}\n\t};\n}\n\nfunction locate ( source, search, startIndex ) {\n\treturn getLocator( source )( search, startIndex );\n}\n\nvar validNameCharacters = /[a-zA-Z0-9:-]/;\nvar whitespace = /[\\s\\t\\r\\n]/;\nvar quotemark = /['\"]/;\n\nfunction repeat ( str, i ) {\n\tvar result = '';\n\twhile ( i-- ) result += str;\n\treturn result;\n}\n\nfunction parse$1 ( source ) {\n\tvar match = /^<\\?.+?\\?>/.exec( source );\n\tvar metadata = match ? match[0] : '';\n\n\tvar stack = [];\n\n\tvar state = neutral;\n\tvar currentElement = null;\n\tvar root = null;\n\n\tfunction error ( message ) {\n\t\tvar ref = locate( source, i );\n\t\tvar line = ref.line;\n\t\tvar column = ref.column;\n\t\tvar before = source.slice( 0, i ).replace( /^\\t+/, function (match) { return repeat( '  ', match.length ); } );\n\t\tvar beforeLine = /(^|\\n).*$/.exec( before )[0];\n\t\tvar after = source.slice( i );\n\t\tvar afterLine = /.*(\\n|$)/.exec( after )[0];\n\n\t\tvar snippet = \"\" + beforeLine + afterLine + \"\\n\" + (repeat( ' ', beforeLine.length )) + \"^\";\n\n\t\tthrow new Error( (message + \" (\" + line + \":\" + column + \"). If this is valid SVG, it's probably a bug in svg-parser. Please raise an issue at https://gitlab.com/Rich-Harris/svg-parser/issues – thanks!\\n\\n\" + snippet) );\n\t}\n\n\tfunction neutral () {\n\t\tvar text = '';\n\t\twhile ( i < source.length && source[i] !== '<' ) text += source[ i++ ];\n\n\t\tif ( /\\S/.test( text ) ) {\n\t\t\tcurrentElement.children.push( text );\n\t\t}\n\n\t\tif ( source[i] === '<' ) {\n\t\t\treturn tag;\n\t\t}\n\n\t\treturn neutral;\n\t}\n\n\tfunction tag () {\n\t\tif ( source[i] === '!' ) {\n\t\t\treturn comment;\n\t\t}\n\n\t\tif ( source[i] === '/' ) {\n\t\t\treturn closingTag;\n\t\t}\n\n\t\tvar name = getName();\n\n\t\tvar element = {\n\t\t\tname: name,\n\t\t\tattributes: {},\n\t\t\tchildren: []\n\t\t};\n\n\t\tif ( currentElement ) {\n\t\t\tcurrentElement.children.push( element );\n\t\t} else {\n\t\t\troot = element;\n\t\t}\n\n\t\tvar attribute;\n\t\twhile ( i < source.length && ( attribute = getAttribute() ) ) {\n\t\t\telement.attributes[ attribute.name ] = attribute.value;\n\t\t}\n\n\t\tvar selfClosing = false;\n\n\t\tif ( source[i] === '/' ) {\n\t\t\ti += 1;\n\t\t\tselfClosing = true;\n\t\t}\n\n\t\tif ( source[i] !== '>' ) {\n\t\t\terror( 'Expected >' );\n\t\t}\n\n\t\tif ( !selfClosing ) {\n\t\t\tcurrentElement = element;\n\t\t\tstack.push( element );\n\t\t}\n\n\t\treturn neutral;\n\t}\n\n\tfunction comment () {\n\t\tvar index = source.indexOf( '-->', i );\n\t\tif ( !~index ) error( 'expected -->' );\n\n\t\ti = index + 3;\n\t\treturn neutral;\n\t}\n\n\tfunction closingTag () {\n\t\tvar name = getName();\n\n\t\tif ( !name ) error( 'Expected tag name' );\n\n\t\tif ( name !== currentElement.name ) {\n\t\t\terror( (\"Expected closing tag </\" + name + \"> to match opening tag <\" + (currentElement.name) + \">\") );\n\t\t}\n\n\t\tif ( source[i] !== '>' ) {\n\t\t\terror( 'Expected >' );\n\t\t}\n\n\t\tstack.pop();\n\t\tcurrentElement = stack[ stack.length - 1 ];\n\n\t\treturn neutral;\n\t}\n\n\tfunction getName () {\n\t\tvar name = '';\n\t\twhile ( i < source.length && validNameCharacters.test( source[i] ) ) name += source[ i++ ];\n\n\t\treturn name;\n\t}\n\n\tfunction getAttribute () {\n\t\tif ( !whitespace.test( source[i] ) ) return null;\n\t\tallowSpaces();\n\n\t\tvar name = getName();\n\t\tif ( !name ) return null;\n\n\t\tvar value = true;\n\n\t\tallowSpaces();\n\t\tif ( source[i] === '=' ) {\n\t\t\ti += 1;\n\t\t\tallowSpaces();\n\n\t\t\tvalue = getAttributeValue();\n\t\t\tif ( !isNaN( value ) ) value = +value; // TODO whitelist numeric attributes?\n\t\t}\n\n\t\treturn { name: name, value: value };\n\t}\n\n\tfunction getAttributeValue () {\n\t\treturn quotemark.test( source[i] ) ?\n\t\t\tgetQuotedAttributeValue() :\n\t\t\tgetUnquotedAttributeValue();\n\t}\n\n\tfunction getUnquotedAttributeValue () {\n\t\tvar value = '';\n\t\tdo {\n\t\t\tvar char = source[i];\n\t\t\tif ( char === ' ' || char === '>' || char === '/' ) {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tvalue += char;\n\t\t\ti += 1;\n\t\t} while ( i < source.length );\n\n\t\treturn value;\n\t}\n\n\tfunction getQuotedAttributeValue () {\n\t\tvar quotemark = source[ i++ ];\n\n\t\tvar value = '';\n\t\tvar escaped = false;\n\n\t\twhile ( i < source.length ) {\n\t\t\tvar char = source[ i++ ];\n\t\t\tif ( char === quotemark && !escaped ) {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tif ( char === '\\\\' && !escaped ) {\n\t\t\t\tescaped = true;\n\t\t\t}\n\n\t\t\tvalue += escaped ? (\"\\\\\" + char) : char;\n\t\t\tescaped = false;\n\t\t}\n\t}\n\n\tfunction allowSpaces () {\n\t\twhile ( i < source.length && whitespace.test( source[i] ) ) i += 1;\n\t}\n\n\tvar i = metadata.length;\n\twhile ( i < source.length ) {\n\t\tif ( !state ) error( 'Unexpected character' );\n\t\tstate = state();\n\t\ti += 1;\n\t}\n\n\tif ( state !== neutral ) {\n\t\terror( 'Unexpected end of input' );\n\t}\n\n\tif ( root.name === 'svg' ) root.metadata = metadata;\n\treturn root;\n}\n\nvar assign = Object.assign || function assign ( source ) {\n\tvar targets = [], len = arguments.length - 1;\n\twhile ( len-- > 0 ) targets[ len ] = arguments[ len + 1 ];\n\n\ttargets.forEach( function (target) {\n\t\tObject.keys( target ).forEach( function (key) {\n\t\t\tsource[ key ] = target[ key ];\n\t\t});\n\t});\n};\n\nfunction cloneExcept ( obj, props ) {\n\tvar clone = {};\n\tObject.keys( obj ).forEach( function (prop) {\n\t\tif ( !~props.indexOf( prop ) ) clone[ prop ] = obj[ prop ];\n\t});\n\treturn clone;\n}\n\nfunction line ( points ) {\n\tvar path = '';\n\tvar prefix = 'M';\n\n\tfor ( var i = 0; i < points.length; i += 2 ) {\n\t\tpath += \"\" + prefix + (points[i]) + \",\" + (points[i+1]);\n\t\tprefix = ' ';\n\t}\n\n\treturn path;\n}\n\nvar converters = {\n\tellipse: function (attributes) {\n\t\tvar cx = attributes.cx || 0;\n\t\tvar cy = attributes.cy || 0;\n\t\tvar rx = attributes.rx || 0;\n\t\tvar ry = attributes.ry || 0;\n\n\t\tvar path = cloneExcept( attributes, [ 'cx', 'cy', 'rx', 'ry' ] );\n\t\tpath.d = \"M\" + (cx - rx) + \",\" + cy + \"a\" + rx + \",\" + ry + \" 0 1,0 \" + (rx * 2) + \",0a\" + rx + \",\" + ry + \" 0 1,0 \" + (rx * -2) + \",0\";\n\n\t\treturn path;\n\t},\n\n\tcircle: function (attributes) {\n\t\tvar cx = attributes.cx || 0;\n\t\tvar cy = attributes.cy || 0;\n\t\tvar r = attributes.r || 0;\n\n\t\tvar path = cloneExcept( attributes, [ 'cx', 'cy', 'r' ] );\n\t\tpath.d = \"M\" + (cx - r) + \",\" + cy + \"a\" + r + \",\" + r + \" 0 1,0 \" + (r * 2) + \",0a\" + r + \",\" + r + \" 0 1,0 \" + (r * -2) + \",0\";\n\n\t\treturn path;\n\t},\n\n\tpolygon: function (attributes) {\n\t\tvar path = converters.polyline( attributes );\n\t\tpath.d += 'Z';\n\n\t\treturn path;\n\t},\n\n\tpolyline: function (attributes) {\n\t\tvar path = cloneExcept( attributes, 'points' );\n\t\tpath.d = line( attributes.points.trim().split( /[\\s,]+/ ) );\n\n\t\treturn path;\n\t},\n\n\trect: function (attributes) {\n\t\tvar x = +attributes.x || 0;\n\t\tvar y = +attributes.y || 0;\n\t\tvar width = +attributes.width || 0;\n\t\tvar height = +attributes.height || 0;\n\t\t// const rx = +attributes.rx || 0; // TODO handle...\n\t\t// const ry = +attributes.ry || 0; // TODO handle...\n\n\t\tvar path = cloneExcept( attributes, [ 'x', 'y', 'width', 'height', 'rx', 'ry' ] );\n\n\t\t// TODO handle rx and ry\n\t\tpath.d = \"m\" + x + \",\" + y + \" \" + width + \",0 0,\" + height + \" \" + (-width) + \",0Z\";\n\n\t\treturn path;\n\t},\n\n\tline: function (attributes) {\n\t\tvar path = cloneExcept( attributes, [ 'x1', 'y1', 'x2', 'y2' ]);\n\t\tpath.d = line([ attributes.x1 || 0, attributes.y1 || 0, attributes.x2 || 0, attributes.y2 || 0 ]);\n\n\t\treturn path;\n\t}\n\n\t// TODO others...\n};\n\nfunction convert ( node ) {\n\tvar converter = converters[ node.name ];\n\tif ( converter ) {\n\t\tvar attributes = converter( node.attributes );\n\n\t\treturn {\n\t\t\tname: 'path',\n\t\t\tattributes: attributes\n\t\t};\n\t}\n\n\tthrow new Error( (\"TODO <\" + (node.name) + \">\") );\n}\n\nfunction applyAttributes ( node, attributes ) {\n\tnode.attributes = assign( attributes, node.attributes );\n}\n\nfunction applyClasses ( node, classes ) {\n\tif ( node.attributes.class ) {\n\t\tclasses = assign( {}, classes );\n\n\t\tnode.attributes.class.split( ' ' )\n\t\t\t.filter( Boolean )\n\t\t\t.forEach( function (className) { return classes[ className ] = true; } );\n\t}\n\n\tvar classList = Object.keys( classes ).join( ' ' );\n\n\tif ( classList ) {\n\t\tnode.attributes.class = classList;\n\t}\n}\n\nfunction interopDefault(ex) {\n\treturn ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar path_parse = createCommonjsModule(function (module) {\n'use strict';\n\n\nvar paramCounts = { a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0 };\n\nvar SPECIAL_SPACES = [\n  0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006,\n  0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF\n];\n\nfunction isSpace(ch) {\n  return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029) || // Line terminators\n    // White spaces\n    (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n    (ch >= 0x1680 && SPECIAL_SPACES.indexOf(ch) >= 0);\n}\n\nfunction isCommand(code) {\n  /*eslint-disable no-bitwise*/\n  switch (code | 0x20) {\n    case 0x6D/* m */:\n    case 0x7A/* z */:\n    case 0x6C/* l */:\n    case 0x68/* h */:\n    case 0x76/* v */:\n    case 0x63/* c */:\n    case 0x73/* s */:\n    case 0x71/* q */:\n    case 0x74/* t */:\n    case 0x61/* a */:\n    case 0x72/* r */:\n      return true;\n  }\n  return false;\n}\n\nfunction isDigit(code) {\n  return (code >= 48 && code <= 57);   // 0..9\n}\n\nfunction isDigitStart(code) {\n  return (code >= 48 && code <= 57) || /* 0..9 */\n          code === 0x2B || /* + */\n          code === 0x2D || /* - */\n          code === 0x2E;   /* . */\n}\n\n\nfunction State(path) {\n  this.index  = 0;\n  this.path   = path;\n  this.max    = path.length;\n  this.result = [];\n  this.param  = 0.0;\n  this.err    = '';\n  this.segmentStart = 0;\n  this.data   = [];\n}\n\nfunction skipSpaces(state) {\n  while (state.index < state.max && isSpace(state.path.charCodeAt(state.index))) {\n    state.index++;\n  }\n}\n\n\nfunction scanParam(state) {\n  var start = state.index,\n      index = start,\n      max = state.max,\n      zeroFirst = false,\n      hasCeiling = false,\n      hasDecimal = false,\n      hasDot = false,\n      ch;\n\n  if (index >= max) {\n    state.err = 'SvgPath: missed param (at pos ' + index + ')';\n    return;\n  }\n  ch = state.path.charCodeAt(index);\n\n  if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n    index++;\n    ch = (index < max) ? state.path.charCodeAt(index) : 0;\n  }\n\n  // This logic is shamelessly borrowed from Esprima\n  // https://github.com/ariya/esprimas\n  //\n  if (!isDigit(ch) && ch !== 0x2E/* . */) {\n    state.err = 'SvgPath: param should start with 0..9 or `.` (at pos ' + index + ')';\n    return;\n  }\n\n  if (ch !== 0x2E/* . */) {\n    zeroFirst = (ch === 0x30/* 0 */);\n    index++;\n\n    ch = (index < max) ? state.path.charCodeAt(index) : 0;\n\n    if (zeroFirst && index < max) {\n      // decimal number starts with '0' such as '09' is illegal.\n      if (ch && isDigit(ch)) {\n        state.err = 'SvgPath: numbers started with `0` such as `09` are ilegal (at pos ' + start + ')';\n        return;\n      }\n    }\n\n    while (index < max && isDigit(state.path.charCodeAt(index))) {\n      index++;\n      hasCeiling = true;\n    }\n    ch = (index < max) ? state.path.charCodeAt(index) : 0;\n  }\n\n  if (ch === 0x2E/* . */) {\n    hasDot = true;\n    index++;\n    while (isDigit(state.path.charCodeAt(index))) {\n      index++;\n      hasDecimal = true;\n    }\n    ch = (index < max) ? state.path.charCodeAt(index) : 0;\n  }\n\n  if (ch === 0x65/* e */ || ch === 0x45/* E */) {\n    if (hasDot && !hasCeiling && !hasDecimal) {\n      state.err = 'SvgPath: invalid float exponent (at pos ' + index + ')';\n      return;\n    }\n\n    index++;\n\n    ch = (index < max) ? state.path.charCodeAt(index) : 0;\n    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n      index++;\n    }\n    if (index < max && isDigit(state.path.charCodeAt(index))) {\n      while (index < max && isDigit(state.path.charCodeAt(index))) {\n        index++;\n      }\n    } else {\n      state.err = 'SvgPath: invalid float exponent (at pos ' + index + ')';\n      return;\n    }\n  }\n\n  state.index = index;\n  state.param = parseFloat(state.path.slice(start, index)) + 0.0;\n}\n\n\nfunction finalizeSegment(state) {\n  var cmd, cmdLC;\n\n  // Process duplicated commands (without comand name)\n\n  // This logic is shamelessly borrowed from Raphael\n  // https://github.com/DmitryBaranovskiy/raphael/\n  //\n  cmd   = state.path[state.segmentStart];\n  cmdLC = cmd.toLowerCase();\n\n  var params = state.data;\n\n  if (cmdLC === 'm' && params.length > 2) {\n    state.result.push([ cmd, params[0], params[1] ]);\n    params = params.slice(2);\n    cmdLC = 'l';\n    cmd = (cmd === 'm') ? 'l' : 'L';\n  }\n\n  if (cmdLC === 'r') {\n    state.result.push([ cmd ].concat(params));\n  } else {\n\n    while (params.length >= paramCounts[cmdLC]) {\n      state.result.push([ cmd ].concat(params.splice(0, paramCounts[cmdLC])));\n      if (!paramCounts[cmdLC]) {\n        break;\n      }\n    }\n  }\n}\n\n\nfunction scanSegment(state) {\n  var max = state.max, cmdCode, comma_found,\n            need_params, i;\n\n  state.segmentStart = state.index;\n  cmdCode = state.path.charCodeAt(state.index);\n\n  if (!isCommand(cmdCode)) {\n    state.err = 'SvgPath: bad command ' + state.path[state.index] + ' (at pos ' + state.index + ')';\n    return;\n  }\n\n  need_params = paramCounts[state.path[state.index].toLowerCase()];\n\n  state.index++;\n  skipSpaces(state);\n\n  state.data = [];\n\n  if (!need_params) {\n    // Z\n    finalizeSegment(state);\n    return;\n  }\n\n  comma_found = false;\n\n  for (;;) {\n    for (i = need_params; i > 0; i--) {\n      scanParam(state);\n      if (state.err.length) {\n        return;\n      }\n      state.data.push(state.param);\n\n      skipSpaces(state);\n      comma_found = false;\n\n      if (state.index < max && state.path.charCodeAt(state.index) === 0x2C/* , */) {\n        state.index++;\n        skipSpaces(state);\n        comma_found = true;\n      }\n    }\n\n    // after ',' param is mandatory\n    if (comma_found) {\n      continue;\n    }\n\n    if (state.index >= state.max) {\n      break;\n    }\n\n    // Stop on next segment\n    if (!isDigitStart(state.path.charCodeAt(state.index))) {\n      break;\n    }\n  }\n\n  finalizeSegment(state);\n}\n\n\n/* Returns array of segments:\n *\n * [\n *   [ command, coord1, coord2, ... ]\n * ]\n */\nmodule.exports = function pathParse(svgPath) {\n  var state = new State(svgPath);\n  var max = state.max;\n\n  skipSpaces(state);\n\n  while (state.index < max && !state.err.length) {\n    scanSegment(state);\n  }\n\n  if (state.err.length) {\n    state.result = [];\n\n  } else if (state.result.length) {\n\n    if ('mM'.indexOf(state.result[0][0]) < 0) {\n      state.err = 'SvgPath: string should start with `M` or `m`';\n      state.result = [];\n    } else {\n      state.result[0][0] = 'M';\n    }\n  }\n\n  return {\n    err: state.err,\n    segments: state.result\n  };\n};\n});\n\nvar path_parse$1 = interopDefault(path_parse);\n\n\nvar require$$4 = Object.freeze({\n  default: path_parse$1\n});\n\nvar matrix = createCommonjsModule(function (module) {\n'use strict';\n\n// combine 2 matrixes\n// m1, m2 - [a, b, c, d, e, g]\n//\nfunction combine(m1, m2) {\n  return [\n    m1[0] * m2[0] + m1[2] * m2[1],\n    m1[1] * m2[0] + m1[3] * m2[1],\n    m1[0] * m2[2] + m1[2] * m2[3],\n    m1[1] * m2[2] + m1[3] * m2[3],\n    m1[0] * m2[4] + m1[2] * m2[5] + m1[4],\n    m1[1] * m2[4] + m1[3] * m2[5] + m1[5]\n  ];\n}\n\n\nfunction Matrix() {\n  if (!(this instanceof Matrix)) { return new Matrix(); }\n  this.queue = [];   // list of matrixes to apply\n  this.cache = null; // combined matrix cache\n}\n\n\nMatrix.prototype.matrix = function (m) {\n  if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1 && m[4] === 0 && m[5] === 0) {\n    return this;\n  }\n  this.cache = null;\n  this.queue.push(m);\n  return this;\n};\n\n\nMatrix.prototype.translate = function (tx, ty) {\n  if (tx !== 0 || ty !== 0) {\n    this.cache = null;\n    this.queue.push([ 1, 0, 0, 1, tx, ty ]);\n  }\n  return this;\n};\n\n\nMatrix.prototype.scale = function (sx, sy) {\n  if (sx !== 1 || sy !== 1) {\n    this.cache = null;\n    this.queue.push([ sx, 0, 0, sy, 0, 0 ]);\n  }\n  return this;\n};\n\n\nMatrix.prototype.rotate = function (angle, rx, ry) {\n  var rad, cos, sin;\n\n  if (angle !== 0) {\n    this.translate(rx, ry);\n\n    rad = angle * Math.PI / 180;\n    cos = Math.cos(rad);\n    sin = Math.sin(rad);\n\n    this.queue.push([ cos, sin, -sin, cos, 0, 0 ]);\n    this.cache = null;\n\n    this.translate(-rx, -ry);\n  }\n  return this;\n};\n\n\nMatrix.prototype.skewX = function (angle) {\n  if (angle !== 0) {\n    this.cache = null;\n    this.queue.push([ 1, 0, Math.tan(angle * Math.PI / 180), 1, 0, 0 ]);\n  }\n  return this;\n};\n\n\nMatrix.prototype.skewY = function (angle) {\n  if (angle !== 0) {\n    this.cache = null;\n    this.queue.push([ 1, Math.tan(angle * Math.PI / 180), 0, 1, 0, 0 ]);\n  }\n  return this;\n};\n\n\n// Flatten queue\n//\nMatrix.prototype.toArray = function () {\n  var this$1 = this;\n\n  if (this.cache) {\n    return this.cache;\n  }\n\n  if (!this.queue.length) {\n    this.cache = [ 1, 0, 0, 1, 0, 0 ];\n    return this.cache;\n  }\n\n  this.cache = this.queue[0];\n\n  if (this.queue.length === 1) {\n    return this.cache;\n  }\n\n  for (var i = 1; i < this.queue.length; i++) {\n    this$1.cache = combine(this$1.cache, this$1.queue[i]);\n  }\n\n  return this.cache;\n};\n\n\n// Apply list of matrixes to (x,y) point.\n// If `isRelative` set, `translate` component of matrix will be skipped\n//\nMatrix.prototype.calc = function (x, y, isRelative) {\n  var m, i, len;\n\n  // Don't change point on empty transforms queue\n  if (!this.queue.length) { return [ x, y ]; }\n\n  // Calculate final matrix, if not exists\n  //\n  // NB. if you deside to apply transforms to point one-by-one,\n  // they should be taken in reverse order\n\n  if (!this.cache) {\n    this.cache = this.toArray();\n  }\n\n  m = this.cache;\n\n  // Apply matrix to point\n  return [\n    x * m[0] + y * m[2] + (isRelative ? 0 : m[4]),\n    x * m[1] + y * m[3] + (isRelative ? 0 : m[5])\n  ];\n};\n\n\nmodule.exports = Matrix;\n});\n\nvar matrix$1 = interopDefault(matrix);\n\n\nvar require$$0$1 = Object.freeze({\n  default: matrix$1\n});\n\nvar transform_parse = createCommonjsModule(function (module) {\n'use strict';\n\n\nvar Matrix = interopDefault(require$$0$1);\n\nvar operations = {\n  matrix: true,\n  scale: true,\n  rotate: true,\n  translate: true,\n  skewX: true,\n  skewY: true\n};\n\nvar CMD_SPLIT_RE    = /\\s*(matrix|translate|scale|rotate|skewX|skewY)\\s*\\(\\s*(.+?)\\s*\\)[\\s,]*/;\nvar PARAMS_SPLIT_RE = /[\\s,]+/;\n\n\nmodule.exports = function transformParse(transformString) {\n  var matrix = new Matrix();\n  var cmd, params;\n\n  // Split value into ['', 'translate', '10 50', '', 'scale', '2', '', 'rotate',  '-45', '']\n  transformString.split(CMD_SPLIT_RE).forEach(function (item) {\n\n    // Skip empty elements\n    if (!item.length) { return; }\n\n    // remember operation\n    if (typeof operations[item] !== 'undefined') {\n      cmd = item;\n      return;\n    }\n\n    // extract params & att operation to matrix\n    params = item.split(PARAMS_SPLIT_RE).map(function (i) {\n      return +i || 0;\n    });\n\n    // If params count is not correct - ignore command\n    switch (cmd) {\n      case 'matrix':\n        if (params.length === 6) {\n          matrix.matrix(params);\n        }\n        return;\n\n      case 'scale':\n        if (params.length === 1) {\n          matrix.scale(params[0], params[0]);\n        } else if (params.length === 2) {\n          matrix.scale(params[0], params[1]);\n        }\n        return;\n\n      case 'rotate':\n        if (params.length === 1) {\n          matrix.rotate(params[0], 0, 0);\n        } else if (params.length === 3) {\n          matrix.rotate(params[0], params[1], params[2]);\n        }\n        return;\n\n      case 'translate':\n        if (params.length === 1) {\n          matrix.translate(params[0], 0);\n        } else if (params.length === 2) {\n          matrix.translate(params[0], params[1]);\n        }\n        return;\n\n      case 'skewX':\n        if (params.length === 1) {\n          matrix.skewX(params[0]);\n        }\n        return;\n\n      case 'skewY':\n        if (params.length === 1) {\n          matrix.skewY(params[0]);\n        }\n        return;\n    }\n  });\n\n  return matrix;\n};\n});\n\nvar transform_parse$1 = interopDefault(transform_parse);\n\n\nvar require$$3 = Object.freeze({\n  default: transform_parse$1\n});\n\nvar a2c = createCommonjsModule(function (module) {\n// Convert an arc to a sequence of cubic bézier curves\n//\n'use strict';\n\n\nvar TAU = Math.PI * 2;\n\n\n/* eslint-disable space-infix-ops */\n\n// Calculate an angle between two vectors\n//\nfunction vector_angle(ux, uy, vx, vy) {\n  var sign = (ux * vy - uy * vx < 0) ? -1 : 1;\n  var umag = Math.sqrt(ux * ux + uy * uy);\n  var vmag = Math.sqrt(ux * ux + uy * uy);\n  var dot  = ux * vx + uy * vy;\n  var div  = dot / (umag * vmag);\n\n  // rounding errors, e.g. -1.0000000000000002 can screw up this\n  if (div >  1.0) { div =  1.0; }\n  if (div < -1.0) { div = -1.0; }\n\n  return sign * Math.acos(div);\n}\n\n\n// Convert from endpoint to center parameterization,\n// see http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n//\n// Return [cx, cy, θ1, Δθ]\n//\nfunction get_arc_center(x1, y1, x2, y2, fa, fs, rx, ry, sin_φ, cos_φ) {\n  // Step 1.\n  //\n  // Moving an ellipse so origin will be the middlepoint between our two\n  // points. After that, rotate it to line up ellipse axes with coordinate\n  // axes.\n  //\n  var x1p =  cos_φ*(x1-x2)/2 + sin_φ*(y1-y2)/2;\n  var y1p = -sin_φ*(x1-x2)/2 + cos_φ*(y1-y2)/2;\n\n  var rx_sq  =  rx * rx;\n  var ry_sq  =  ry * ry;\n  var x1p_sq = x1p * x1p;\n  var y1p_sq = y1p * y1p;\n\n  // Step 2.\n  //\n  // Compute coordinates of the centre of this ellipse (cx', cy')\n  // in the new coordinate system.\n  //\n  var radicant = (rx_sq * ry_sq) - (rx_sq * y1p_sq) - (ry_sq * x1p_sq);\n\n  if (radicant < 0) {\n    // due to rounding errors it might be e.g. -1.3877787807814457e-17\n    radicant = 0;\n  }\n\n  radicant /=   (rx_sq * y1p_sq) + (ry_sq * x1p_sq);\n  radicant = Math.sqrt(radicant) * (fa === fs ? -1 : 1);\n\n  var cxp = radicant *  rx/ry * y1p;\n  var cyp = radicant * -ry/rx * x1p;\n\n  // Step 3.\n  //\n  // Transform back to get centre coordinates (cx, cy) in the original\n  // coordinate system.\n  //\n  var cx = cos_φ*cxp - sin_φ*cyp + (x1+x2)/2;\n  var cy = sin_φ*cxp + cos_φ*cyp + (y1+y2)/2;\n\n  // Step 4.\n  //\n  // Compute angles (θ1, Δθ).\n  //\n  var v1x =  (x1p - cxp) / rx;\n  var v1y =  (y1p - cyp) / ry;\n  var v2x = (-x1p - cxp) / rx;\n  var v2y = (-y1p - cyp) / ry;\n\n  var θ1 = vector_angle(1, 0, v1x, v1y);\n  var Δθ = vector_angle(v1x, v1y, v2x, v2y);\n\n  if (fs === 0 && Δθ > 0) {\n    Δθ -= TAU;\n  }\n  if (fs === 1 && Δθ < 0) {\n    Δθ += TAU;\n  }\n\n  return [ cx, cy, θ1, Δθ ];\n}\n\n//\n// Approximate one unit arc segment with bézier curves,\n// see http://math.stackexchange.com/questions/873224\n//\nfunction approximate_unit_arc(θ1, Δθ) {\n  var α = 4/3 * Math.tan(Δθ/4);\n\n  var x1 = Math.cos(θ1);\n  var y1 = Math.sin(θ1);\n  var x2 = Math.cos(θ1 + Δθ);\n  var y2 = Math.sin(θ1 + Δθ);\n\n  return [ x1, y1, x1 - y1*α, y1 + x1*α, x2 + y2*α, y2 - x2*α, x2, y2 ];\n}\n\nmodule.exports = function a2c(x1, y1, x2, y2, fa, fs, rx, ry, φ) {\n  var sin_φ = Math.sin(φ * TAU / 360);\n  var cos_φ = Math.cos(φ * TAU / 360);\n\n  // Make sure radii are valid\n  //\n  var x1p =  cos_φ*(x1-x2)/2 + sin_φ*(y1-y2)/2;\n  var y1p = -sin_φ*(x1-x2)/2 + cos_φ*(y1-y2)/2;\n\n  if (x1p === 0 && y1p === 0) {\n    // we're asked to draw line to itself\n    return [];\n  }\n\n  if (rx === 0 || ry === 0) {\n    // one of the radii is zero\n    return [];\n  }\n\n\n  // Compensate out-of-range radii\n  //\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n\n  var Λ = (x1p * x1p) / (rx * rx) + (y1p * y1p) / (ry * ry);\n  if (Λ > 1) {\n    rx *= Math.sqrt(Λ);\n    ry *= Math.sqrt(Λ);\n  }\n\n\n  // Get center parameters (cx, cy, θ1, Δθ)\n  //\n  var cc = get_arc_center(x1, y1, x2, y2, fa, fs, rx, ry, sin_φ, cos_φ);\n\n  var result = [];\n  var θ1 = cc[2];\n  var Δθ = cc[3];\n\n  // Split an arc to multiple segments, so each segment\n  // will be less than τ/4 (= 90°)\n  //\n  var segments = Math.max(Math.ceil(Math.abs(Δθ) / (TAU / 4)), 1);\n  Δθ /= segments;\n\n  for (var i = 0; i < segments; i++) {\n    result.push(approximate_unit_arc(θ1, Δθ));\n    θ1 += Δθ;\n  }\n\n  // We have a bezier approximation of a unit circle,\n  // now need to transform back to the original ellipse\n  //\n  return result.map(function (curve) {\n    for (var i = 0; i < curve.length; i += 2) {\n      var x = curve[i + 0];\n      var y = curve[i + 1];\n\n      // scale\n      x *= rx;\n      y *= ry;\n\n      // rotate\n      var xp = cos_φ*x - sin_φ*y;\n      var yp = sin_φ*x + cos_φ*y;\n\n      // translate\n      curve[i + 0] = xp + cc[0];\n      curve[i + 1] = yp + cc[1];\n    }\n\n    return curve;\n  });\n};\n});\n\nvar a2c$1 = interopDefault(a2c);\n\n\nvar require$$1 = Object.freeze({\n  default: a2c$1\n});\n\nvar ellipse = createCommonjsModule(function (module) {\n'use strict';\n\n/* eslint-disable space-infix-ops */\n\n// The precision used to consider an ellipse as a circle\n//\nvar epsilon = 0.0000000001;\n\n// To convert degree in radians\n//\nvar torad = Math.PI / 180;\n\n// Class constructor :\n//  an ellipse centred at 0 with radii rx,ry and x - axis - angle ax.\n//\nfunction Ellipse(rx, ry, ax) {\n  if (!(this instanceof Ellipse)) { return new Ellipse(rx, ry, ax); }\n  this.rx = rx;\n  this.ry = ry;\n  this.ax = ax;\n}\n\n// Apply a linear transform m to the ellipse\n// m is an array representing a matrix :\n//    -         -\n//   | m[0] m[2] |\n//   | m[1] m[3] |\n//    -         -\n//\nEllipse.prototype.transform = function (m) {\n  // We consider the current ellipse as image of the unit circle\n  // by first scale(rx,ry) and then rotate(ax) ...\n  // So we apply ma =  m x rotate(ax) x scale(rx,ry) to the unit circle.\n  var c = Math.cos(this.ax * torad), s = Math.sin(this.ax * torad);\n  var ma = [ this.rx * (m[0]*c + m[2]*s),\n             this.rx * (m[1]*c + m[3]*s),\n             this.ry * (-m[0]*s + m[2]*c),\n             this.ry * (-m[1]*s + m[3]*c) ];\n\n  // ma * transpose(ma) = [ J L ]\n  //                      [ L K ]\n  // L is calculated later (if the image is not a circle)\n  var J = ma[0]*ma[0] + ma[2]*ma[2],\n      K = ma[1]*ma[1] + ma[3]*ma[3];\n\n  // the discriminant of the characteristic polynomial of ma * transpose(ma)\n  var D = ((ma[0]-ma[3])*(ma[0]-ma[3]) + (ma[2]+ma[1])*(ma[2]+ma[1])) *\n          ((ma[0]+ma[3])*(ma[0]+ma[3]) + (ma[2]-ma[1])*(ma[2]-ma[1]));\n\n  // the \"mean eigenvalue\"\n  var JK = (J + K) / 2;\n\n  // check if the image is (almost) a circle\n  if (D < epsilon * JK) {\n    // if it is\n    this.rx = this.ry = Math.sqrt(JK);\n    this.ax = 0;\n    return this;\n  }\n\n  // if it is not a circle\n  var L = ma[0]*ma[1] + ma[2]*ma[3];\n\n  D = Math.sqrt(D);\n\n  // {l1,l2} = the two eigen values of ma * transpose(ma)\n  var l1 = JK + D/2,\n      l2 = JK - D/2;\n  // the x - axis - rotation angle is the argument of the l1 - eigenvector\n  this.ax = (Math.abs(L) < epsilon && Math.abs(l1 - K) < epsilon) ?\n    90\n  :\n    Math.atan(Math.abs(L) > Math.abs(l1 - K) ?\n      (l1 - J) / L\n    :\n      L / (l1 - K)\n    ) * 180 / Math.PI;\n\n  // if ax > 0 => rx = sqrt(l1), ry = sqrt(l2), else exchange axes and ax += 90\n  if (this.ax >= 0) {\n    // if ax in [0,90]\n    this.rx = Math.sqrt(l1);\n    this.ry = Math.sqrt(l2);\n  } else {\n    // if ax in ]-90,0[ => exchange axes\n    this.ax += 90;\n    this.rx = Math.sqrt(l2);\n    this.ry = Math.sqrt(l1);\n  }\n\n  return this;\n};\n\n// Check if the ellipse is (almost) degenerate, i.e. rx = 0 or ry = 0\n//\nEllipse.prototype.isDegenerate = function () {\n  return (this.rx < epsilon * this.ry || this.ry < epsilon * this.rx);\n};\n\nmodule.exports = Ellipse;\n});\n\nvar ellipse$1 = interopDefault(ellipse);\n\n\nvar require$$0$2 = Object.freeze({\n  default: ellipse$1\n});\n\nvar svgpath$1 = createCommonjsModule(function (module) {\n// SVG Path transformations library\n//\n// Usage:\n//\n//    SvgPath('...')\n//      .translate(-150, -100)\n//      .scale(0.5)\n//      .translate(-150, -100)\n//      .toFixed(1)\n//      .toString()\n//\n\n'use strict';\n\n\nvar pathParse      = interopDefault(require$$4);\nvar transformParse = interopDefault(require$$3);\nvar matrix         = interopDefault(require$$0$1);\nvar a2c            = interopDefault(require$$1);\nvar ellipse        = interopDefault(require$$0$2);\n\n\n// Class constructor\n//\nfunction SvgPath(path) {\n  if (!(this instanceof SvgPath)) { return new SvgPath(path); }\n\n  var pstate = pathParse(path);\n\n  // Array of path segments.\n  // Each segment is array [command, param1, param2, ...]\n  this.segments = pstate.segments;\n\n  // Error message on parse error.\n  this.err      = pstate.err;\n\n  // Transforms stack for lazy evaluation\n  this.__stack    = [];\n}\n\n\nSvgPath.prototype.__matrix = function (m) {\n  var self = this,\n      ma, sx, sy, angle, arc2line, i;\n\n  // Quick leave for empty matrix\n  if (!m.queue.length) { return; }\n\n  this.iterate(function (s, index, x, y) {\n    var p, result, name, isRelative;\n\n    switch (s[0]) {\n\n      // Process 'assymetric' commands separately\n      case 'v':\n        p      = m.calc(0, s[1], true);\n        result = (p[0] === 0) ? [ 'v', p[1] ] : [ 'l', p[0], p[1] ];\n        break;\n\n      case 'V':\n        p      = m.calc(x, s[1], false);\n        result = (p[0] === m.calc(x, y, false)[0]) ? [ 'V', p[1] ] : [ 'L', p[0], p[1] ];\n        break;\n\n      case 'h':\n        p      = m.calc(s[1], 0, true);\n        result = (p[1] === 0) ? [ 'h', p[0] ] : [ 'l', p[0], p[1] ];\n        break;\n\n      case 'H':\n        p      = m.calc(s[1], y, false);\n        result = (p[1] === m.calc(x, y, false)[1]) ? [ 'H', p[0] ] : [ 'L', p[0], p[1] ];\n        break;\n\n      case 'a':\n      case 'A':\n        // ARC is: ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\n\n        // Drop segment if arc is empty (end point === start point)\n        /*if ((s[0] === 'A' && s[6] === x && s[7] === y) ||\n            (s[0] === 'a' && s[6] === 0 && s[7] === 0)) {\n          return [];\n        }*/\n\n        // Transform rx, ry and the x-axis-rotation\n        var ma = m.toArray();\n        var e = ellipse(s[1], s[2], s[3]).transform(ma);\n\n        // flip sweep-flag if matrix is not orientation-preserving\n        if (ma[0] * ma[3] - ma[1] * ma[2] < 0) {\n          s[5] = s[5] ? '0' : '1';\n        }\n\n        // Transform end point as usual (without translation for relative notation)\n        p = m.calc(s[6], s[7], s[0] === 'a');\n\n        // Empty arcs can be ignored by renderer, but should not be dropped\n        // to avoid collisions with `S A S` and so on. Replace with empty line.\n        if ((s[0] === 'A' && s[6] === x && s[7] === y) ||\n            (s[0] === 'a' && s[6] === 0 && s[7] === 0)) {\n          result = [ s[0] === 'a' ? 'l' : 'L', p[0], p[1] ];\n          break;\n        }\n\n        // if the resulting ellipse is (almost) a segment ...\n        if (e.isDegenerate()) {\n          // replace the arc by a line\n          result = [ s[0] === 'a' ? 'l' : 'L', p[0], p[1] ];\n        } else {\n          // if it is a real ellipse\n          // s[0], s[4] and s[5] are not modified\n          result = [ s[0], e.rx, e.ry, e.ax, s[4], s[5], p[0], p[1] ];\n        }\n\n        break;\n\n      case 'm':\n        // Edge case. The very first `m` should be processed as absolute, if happens.\n        // Make sense for coord shift transforms.\n        isRelative = index > 0;\n\n        p = m.calc(s[1], s[2], isRelative);\n        result = [ 'm', p[0], p[1] ];\n        break;\n\n      default:\n        name       = s[0];\n        result     = [ name ];\n        isRelative = (name.toLowerCase() === name);\n\n        // Apply transformations to the segment\n        for (i = 1; i < s.length; i += 2) {\n          p = m.calc(s[i], s[i + 1], isRelative);\n          result.push(p[0], p[1]);\n        }\n    }\n\n    self.segments[index] = result;\n  }, true);\n};\n\n\n// Apply stacked commands\n//\nSvgPath.prototype.__evaluateStack = function () {\n  var this$1 = this;\n\n  var m, i;\n\n  if (!this.__stack.length) { return; }\n\n  if (this.__stack.length === 1) {\n    this.__matrix(this.__stack[0]);\n    this.__stack = [];\n    return;\n  }\n\n  m = matrix();\n  i = this.__stack.length;\n\n  while (--i >= 0) {\n    m.matrix(this$1.__stack[i].toArray());\n  }\n\n  this.__matrix(m);\n  this.__stack = [];\n};\n\n\n// Convert processed SVG Path back to string\n//\nSvgPath.prototype.toString = function () {\n  var this$1 = this;\n\n  var elements = [], skipCmd, cmd;\n\n  this.__evaluateStack();\n\n  for (var i = 0; i < this.segments.length; i++) {\n    // remove repeating commands names\n    cmd = this$1.segments[i][0];\n    skipCmd = i > 0 && cmd !== 'm' && cmd !== 'M' && cmd === this$1.segments[i - 1][0];\n    elements = elements.concat(skipCmd ? this$1.segments[i].slice(1) : this$1.segments[i]);\n  }\n\n  return elements.join(' ')\n            // Optimizations: remove spaces around commands & before `-`\n            //\n            // We could also remove leading zeros for `0.5`-like values,\n            // but their count is too small to spend time for.\n            .replace(/ ?([achlmqrstvz]) ?/gi, '$1')\n            .replace(/ \\-/g, '-')\n            // workaround for FontForge SVG importing bug\n            .replace(/zm/g, 'z m');\n};\n\n\n// Translate path to (x [, y])\n//\nSvgPath.prototype.translate = function (x, y) {\n  this.__stack.push(matrix().translate(x, y || 0));\n  return this;\n};\n\n\n// Scale path to (sx [, sy])\n// sy = sx if not defined\n//\nSvgPath.prototype.scale = function (sx, sy) {\n  this.__stack.push(matrix().scale(sx, (!sy && (sy !== 0)) ? sx : sy));\n  return this;\n};\n\n\n// Rotate path around point (sx [, sy])\n// sy = sx if not defined\n//\nSvgPath.prototype.rotate = function (angle, rx, ry) {\n  this.__stack.push(matrix().rotate(angle, rx || 0, ry || 0));\n  return this;\n};\n\n\n// Apply matrix transform (array of 6 elements)\n//\nSvgPath.prototype.matrix = function (m) {\n  this.__stack.push(matrix().matrix(m));\n  return this;\n};\n\n\n// Transform path according to \"transform\" attr of SVG spec\n//\nSvgPath.prototype.transform = function (transformString) {\n  if (!transformString.trim()) {\n    return this;\n  }\n  this.__stack.push(transformParse(transformString));\n  return this;\n};\n\n\n// Round coords with given decimal precition.\n// 0 by default (to integers)\n//\nSvgPath.prototype.round = function (d) {\n  var contourStartDeltaX = 0, contourStartDeltaY = 0, deltaX = 0, deltaY = 0, l;\n\n  d = d || 0;\n\n  this.__evaluateStack();\n\n  this.segments.forEach(function (s) {\n    var isRelative = (s[0].toLowerCase() === s[0]), t;\n\n    switch (s[0]) {\n      case 'H':\n      case 'h':\n        if (isRelative) { s[1] += deltaX; }\n        deltaX = s[1] - s[1].toFixed(d);\n        s[1] = +s[1].toFixed(d);\n        return;\n\n      case 'V':\n      case 'v':\n        if (isRelative) { s[1] += deltaY; }\n        deltaY = s[1] - s[1].toFixed(d);\n        s[1] = +s[1].toFixed(d);\n        return;\n\n      case 'Z':\n      case 'z':\n        deltaX = contourStartDeltaX;\n        deltaY = contourStartDeltaY;\n        return;\n\n      case 'M':\n      case 'm':\n        if (isRelative) {\n          s[1] += deltaX;\n          s[2] += deltaY;\n        }\n\n        deltaX = s[1] - s[1].toFixed(d);\n        deltaY = s[2] - s[2].toFixed(d);\n\n        contourStartDeltaX = deltaX;\n        contourStartDeltaY = deltaY;\n\n        s[1] = +s[1].toFixed(d);\n        s[2] = +s[2].toFixed(d);\n        return;\n\n      case 'A':\n      case 'a':\n        // [cmd, rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\n        if (isRelative) {\n          s[6] += deltaX;\n          s[7] += deltaY;\n        }\n\n        deltaX = s[6] - s[6].toFixed(d);\n        deltaY = s[7] - s[7].toFixed(d);\n\n        s[1] = +s[1].toFixed(d);\n        s[2] = +s[2].toFixed(d);\n        s[3] = +s[3].toFixed(d + 2); // better precision for rotation\n        s[6] = +s[6].toFixed(d);\n        s[7] = +s[7].toFixed(d);\n        return;\n\n      default:\n        // a c l q s t\n        l = s.length;\n\n        if (isRelative) {\n          s[l - 2] += deltaX;\n          s[l - 1] += deltaY;\n        }\n\n        deltaX = s[l - 2] - s[l - 2].toFixed(d);\n        deltaY = s[l - 1] - s[l - 1].toFixed(d);\n\n        s.forEach(function (val, i) {\n          if (!i) { return; }\n          s[i] = +s[i].toFixed(d);\n        });\n        return;\n    }\n  });\n\n  return this;\n};\n\n\n// Apply iterator function to all segments. If function returns result,\n// current segment will be replaced to array of returned segments.\n// If empty array is returned, current regment will be deleted.\n//\nSvgPath.prototype.iterate = function (iterator, keepLazyStack) {\n  var segments = this.segments,\n      replacements = {},\n      needReplace = false,\n      lastX = 0,\n      lastY = 0,\n      countourStartX = 0,\n      countourStartY = 0;\n  var i, j, isRelative, newSegments;\n\n  if (!keepLazyStack) {\n    this.__evaluateStack();\n  }\n\n  segments.forEach(function (s, index) {\n\n    var res = iterator(s, index, lastX, lastY);\n\n    if (Array.isArray(res)) {\n      replacements[index] = res;\n      needReplace = true;\n    }\n\n    var isRelative = (s[0] === s[0].toLowerCase());\n\n    // calculate absolute X and Y\n    switch (s[0]) {\n      case 'm':\n      case 'M':\n        lastX = s[1] + (isRelative ? lastX : 0);\n        lastY = s[2] + (isRelative ? lastY : 0);\n        countourStartX = lastX;\n        countourStartY = lastY;\n        return;\n\n      case 'h':\n      case 'H':\n        lastX = s[1] + (isRelative ? lastX : 0);\n        return;\n\n      case 'v':\n      case 'V':\n        lastY = s[1] + (isRelative ? lastY : 0);\n        return;\n\n      case 'z':\n      case 'Z':\n        // That make sence for multiple contours\n        lastX = countourStartX;\n        lastY = countourStartY;\n        return;\n\n      default:\n        lastX = s[s.length - 2] + (isRelative ? lastX : 0);\n        lastY = s[s.length - 1] + (isRelative ? lastY : 0);\n    }\n  });\n\n  // Replace segments if iterator return results\n\n  if (!needReplace) { return this; }\n\n  newSegments = [];\n\n  for (i = 0; i < segments.length; i++) {\n    if (typeof replacements[i] !== 'undefined') {\n      for (j = 0; j < replacements[i].length; j++) {\n        newSegments.push(replacements[i][j]);\n      }\n    } else {\n      newSegments.push(segments[i]);\n    }\n  }\n\n  this.segments = newSegments;\n\n  return this;\n};\n\n\n// Converts segments from relative to absolute\n//\nSvgPath.prototype.abs = function () {\n\n  this.iterate(function (s, index, x, y) {\n    var name = s[0],\n        nameUC = name.toUpperCase(),\n        i;\n\n    // Skip absolute commands\n    if (name === nameUC) { return; }\n\n    s[0] = nameUC;\n\n    switch (name) {\n      case 'v':\n        // v has shifted coords parity\n        s[1] += y;\n        return;\n\n      case 'a':\n        // ARC is: ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\n        // touch x, y only\n        s[6] += x;\n        s[7] += y;\n        return;\n\n      default:\n        for (i = 1; i < s.length; i++) {\n          s[i] += i % 2 ? x : y; // odd values are X, even - Y\n        }\n    }\n  }, true);\n\n  return this;\n};\n\n\n// Converts segments from absolute to relative\n//\nSvgPath.prototype.rel = function () {\n\n  this.iterate(function (s, index, x, y) {\n    var name = s[0],\n        nameLC = name.toLowerCase(),\n        i;\n\n    // Skip relative commands\n    if (name === nameLC) { return; }\n\n    // Don't touch the first M to avoid potential confusions.\n    if (index === 0 && name === 'M') { return; }\n\n    s[0] = nameLC;\n\n    switch (name) {\n      case 'V':\n        // V has shifted coords parity\n        s[1] -= y;\n        return;\n\n      case 'A':\n        // ARC is: ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\n        // touch x, y only\n        s[6] -= x;\n        s[7] -= y;\n        return;\n\n      default:\n        for (i = 1; i < s.length; i++) {\n          s[i] -= i % 2 ? x : y; // odd values are X, even - Y\n        }\n    }\n  }, true);\n\n  return this;\n};\n\n\n// Converts arcs to cubic bézier curves\n//\nSvgPath.prototype.unarc = function () {\n  this.iterate(function (s, index, x, y) {\n    var i, new_segments, nextX, nextY, result = [], name = s[0];\n\n    // Skip anything except arcs\n    if (name !== 'A' && name !== 'a') { return null; }\n\n    if (name === 'a') {\n      // convert relative arc coordinates to absolute\n      nextX = x + s[6];\n      nextY = y + s[7];\n    } else {\n      nextX = s[6];\n      nextY = s[7];\n    }\n\n    new_segments = a2c(x, y, nextX, nextY, s[4], s[5], s[1], s[2], s[3]);\n\n    // Degenerated arcs can be ignored by renderer, but should not be dropped\n    // to avoid collisions with `S A S` and so on. Replace with empty line.\n    if (new_segments.length === 0) {\n      return [ [ s[0] === 'a' ? 'l' : 'L', s[6], s[7] ] ];\n    }\n\n    new_segments.forEach(function (s) {\n      result.push([ 'C', s[2], s[3], s[4], s[5], s[6], s[7] ]);\n    });\n\n    return result;\n  });\n\n  return this;\n};\n\n\n// Converts smooth curves (with missed control point) to generic curves\n//\nSvgPath.prototype.unshort = function () {\n  var segments = this.segments;\n  var prevControlX, prevControlY, prevSegment;\n  var curControlX, curControlY;\n\n  // TODO: add lazy evaluation flag when relative commands supported\n\n  this.iterate(function (s, idx, x, y) {\n    var name = s[0], nameUC = name.toUpperCase(), isRelative;\n\n    // First command MUST be M|m, it's safe to skip.\n    // Protect from access to [-1] for sure.\n    if (!idx) { return; }\n\n    if (nameUC === 'T') { // quadratic curve\n      isRelative = (name === 't');\n\n      prevSegment = segments[idx - 1];\n\n      if (prevSegment[0] === 'Q') {\n        prevControlX = prevSegment[1] - x;\n        prevControlY = prevSegment[2] - y;\n      } else if (prevSegment[0] === 'q') {\n        prevControlX = prevSegment[1] - prevSegment[3];\n        prevControlY = prevSegment[2] - prevSegment[4];\n      } else {\n        prevControlX = 0;\n        prevControlY = 0;\n      }\n\n      curControlX = -prevControlX;\n      curControlY = -prevControlY;\n\n      if (!isRelative) {\n        curControlX += x;\n        curControlY += y;\n      }\n\n      segments[idx] = [\n        isRelative ? 'q' : 'Q',\n        curControlX, curControlY,\n        s[1], s[2]\n      ];\n\n    } else if (nameUC === 'S') { // cubic curve\n      isRelative = (name === 's');\n\n      prevSegment = segments[idx - 1];\n\n      if (prevSegment[0] === 'C') {\n        prevControlX = prevSegment[3] - x;\n        prevControlY = prevSegment[4] - y;\n      } else if (prevSegment[0] === 'c') {\n        prevControlX = prevSegment[3] - prevSegment[5];\n        prevControlY = prevSegment[4] - prevSegment[6];\n      } else {\n        prevControlX = 0;\n        prevControlY = 0;\n      }\n\n      curControlX = -prevControlX;\n      curControlY = -prevControlY;\n\n      if (!isRelative) {\n        curControlX += x;\n        curControlY += y;\n      }\n\n      segments[idx] = [\n        isRelative ? 'c' : 'C',\n        curControlX, curControlY,\n        s[1], s[2], s[3], s[4]\n      ];\n    }\n  });\n\n  return this;\n};\n\n\nmodule.exports = SvgPath;\n});\n\nvar svgpath$2 = interopDefault(svgpath$1);\n\n\nvar require$$0 = Object.freeze({\n  default: svgpath$2\n});\n\nvar index = createCommonjsModule(function (module) {\n'use strict';\n\nmodule.exports = interopDefault(require$$0);\n});\n\nvar svgpath = interopDefault(index);\n\nfunction applyTransforms ( node, transforms ) {\n\tif ( node.attributes.transform ) {\n\t\ttransforms = transforms.concat( node.attributes.transform );\n\t\tdelete node.attributes.transform;\n\t}\n\n\tvar transformString = transforms.join( ' ' );\n\n\tif ( node.name === 'path' ) {\n\t\tnode.attributes.d = svgpath( node.attributes.d )\n\t\t\t.transform( transformString )\n\t\t\t.round( 10 )\n\t\t\t.toString();\n\t} else if ( transformString ) {\n\t\tnode.attributes.transform = transformString;\n\t}\n}\n\nvar ignore = [ 'defs', 'title' ];\nvar noninheritable = [ 'id', 'class', 'style', 'transform' ];\n\nfunction walk ( node, paths, transforms, classes, attributes ) {\n\tif ( node.name === 'svg' ) {\n\t\tvar _transforms = transforms.slice();\n\t\tnode.children.forEach( function (child) {\n\t\t\twalk( child, paths, _transforms, assign( {}, classes ), assign( {}, attributes ) );\n\t\t});\n\t}\n\n\telse if ( node.name === 'g' ) {\n\t\ttransforms = node.attributes.transform ? transforms.concat( node.attributes.transform ) : transforms;\n\n\t\tif ( node.attributes.class ) {\n\t\t\tnode.attributes.class.split( ' ' )\n\t\t\t\t.filter( Boolean )\n\t\t\t\t.forEach( function (className) { return classes[ className ] = true; } );\n\t\t}\n\n\t\tnode.children.forEach( function (child) {\n\t\t\tvar _classes = assign( {}, classes );\n\n\t\t\tvar _attributes = assign(\n\t\t\t\tcloneExcept( attributes, noninheritable ),\n\t\t\t\tcloneExcept( node.attributes, noninheritable )\n\t\t\t);\n\n\t\t\twalk( child, paths, transforms, _classes, _attributes );\n\t\t});\n\t}\n\n\telse if ( ~ignore.indexOf( node.name ) ) {\n\t\tapplyAttributes( node, attributes );\n\t\tapplyClasses( node, classes );\n\t\tapplyTransforms( node, transforms );\n\t\tpaths.push( node );\n\t}\n\n\telse {\n\t\tapplyAttributes( node, attributes );\n\t\tapplyClasses( node, classes );\n\n\t\tif ( node.name !== 'path' ) {\n\t\t\tnode = convert( node );\n\t\t}\n\n\t\tapplyTransforms( node, transforms );\n\t\tpaths.push( node );\n\t}\n}\n\nfunction stringifyAttributes ( attributes ) {\n\treturn Object.keys( attributes ).map( function (key) { return (\" \" + key + \"=\\\"\" + (attributes[key]) + \"\\\"\"); } ).join( '' );\n}\n\nfunction stringify ( node, indent ) {\n\tif ( typeof node === 'string' ) return node;\n\n\tvar attributes = stringifyAttributes( node.attributes );\n\n\tvar str = indent + \"<\" + (node.name) + attributes;\n\n\tif ( node.children && node.children.length ) {\n\t\tstr += '>';\n\t\tvar prefix = '\\n';\n\n\t\tfor ( var i = 0, list = node.children; i < list.length; i += 1 ) {\n\t\t\tvar child = list[i];\n\n\t\t\tif ( typeof child === 'string' ) {\n\t\t\t\tstr += child;\n\t\t\t\tprefix = '';\n\t\t\t} else {\n\t\t\t\tstr += prefix + stringify( child, indent + '\\t' );\n\t\t\t\tprefix = '\\n';\n\t\t\t}\n\t\t}\n\n\t\tif ( prefix ) prefix += indent;\n\n\t\tstr += prefix + \"</\" + (node.name) + \">\";\n\t} else if ( node.val ) {\n\t\tstr += \">\" + (node.val) + \"</\" + (node.name) + \">\";\n\t} else {\n\t\tstr += '/>';\n\t}\n\n\treturn str;\n}\n\nvar Pathologist = function Pathologist ( source ) {\n\tthis.source = parse$1( source );\n\n\tthis.target = {\n\t\tname: this.source.name,\n\t\tattributes: Object.assign( {}, this.source.attributes ),\n\t\tchildren: []\n\t};\n\n\twalk( this.source, this.target.children, [], {}, {} );\n};\n\nPathologist.prototype.toString = function toString () {\n\treturn stringify( this.target, '' );\n};\n\nfunction transform ( source ) {\n\treturn new Pathologist( source ).toString();\n}\n\nfunction parse ( source ) {\n\tvar pathologist = new Pathologist( source );\n\n\treturn {\n\t\tpaths: pathologist.target.children.filter( function (node) { return node.name === 'path'; } ).map( function (node) { return node.attributes; } ),\n\t\ttoString: function toString () {\n\t\t\treturn pathologist.toString();\n\t\t}\n\t};\n}\n\nexport { transform, parse };\n//# sourceMappingURL=pathologist.es.js.map\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","\r\nimport startApp from './js/startApp'\r\nlet main = function() {\r\n    startApp()\r\n}\r\n\r\nwindow.main = main"],"sourceRoot":""}